package multiClientsFrames;

import algorithms.FileCreater;
import algorithms.File1;
import algorithms.File2;
import hash.Hashes;
import java.io.*;
import java.util.HashMap;
import records.EventType;
import records.FileRecord;

public class ServerReceiveThread extends Thread {

    ClientData client;

    public ServerReceiveThread(ClientData client) {
        this.client = client;
    }

    @Override
    public void run() {
        try {
            while (true) {
                FileRecord fc = (FileRecord) client.in.readObject();
                //System.out.println("Event " + client.id + " : " + msg);
                SharedData.textareaEvents.setText("Event " + client.id + " : " + fc.toMsg() + "\n" + SharedData.textareaEvents.getText());
                SharedData.textareaRecords.setText(fc + "\n" + SharedData.textareaRecords.getText());
                doEvent(fc);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            SharedData.textareaEvents.setText(client.id + " : disconnect" + "\n" + SharedData.textareaEvents.getText());
        }
    }

    public void doEvent(FileRecord fc) throws Exception {
        if (fc.getType() == EventType.rename) {
            File f = new File("Cloud\\Server\\" + fc.getName());
            if (f.renameTo(new File("Cloud\\Server\\" + fc.getNewName()))) {
                //System.out.println(names[0] + " was renamed To " + names[1]);
            }
            // send to all clients
            for (ClientData cd : ServerFrame.clients) {
                if (!cd.id.equals(client.id)) {
                    cd.out.writeObject(fc);
                    cd.out.flush();
                }
            }
        } else if (fc.getType() == EventType.delete) {
            //System.out.println("data[1] = " + data[1]);
            File f = new File("Cloud\\Server\\" + fc.getName());
            if (f.delete()) {
                //System.out.println(data[1] + " was deleted");
            }
            // send to all clients
            for (ClientData cd : ServerFrame.clients) {
                if (!cd.id.equals(client.id)) {
                    cd.out.writeObject(fc);
                    cd.out.flush();
                }
            }
        } else if (fc.getType() == EventType.create) {
            sendWaitRecordAllClients(0);
            //System.out.println("data[1] = " + data[1]);
            File f = new File("Cloud\\Server\\" + fc.getName());
            //System.out.println(data[1] + " was created");
            byte[] fileBytes = receiveCreateFile(f);
            for (ClientData cd : ServerFrame.clients) {
                if (!cd.id.equals(client.id)) {
                    cd.out.writeObject(fc);
                    cd.out.flush();
                    cd.out.writeObject(fileBytes);
                    cd.out.flush();
                }
            }
            sendWaitRecordAllClients(1);
        } else if (fc.getType() == EventType.modify) {
            sendWaitRecordAllClients(0);
            //System.out.println("data[1] = " + data[1]);
            File f = new File("Cloud\\Server\\" + fc.getName());
            //System.out.println(data[1] + " was modified");
            receiveModifyFile(f, fc);
            sendWaitRecordAllClients(1);
        }
    }

    // type==0 create | type==1 modify
    public byte[] receiveCreateFile(File file) throws FileNotFoundException, Exception {
        OutputStream out = new FileOutputStream("Cloud\\Server\\" + file.getName());
        byte[] bytes = null;
        try {
            bytes = (byte[]) client.in.readObject();
            out.write(bytes);
            out.flush();
            out.close();
            return bytes;
        } catch (Exception ex) {
            System.out.println("file receive error");
            //doEvent("deleted:#" + file.getName());
            return null;
        }
    }

    // type==0 create | type==1 modify
    public void receiveModifyFile(File file, FileRecord fc) throws FileNotFoundException, Exception {
        byte[] bytes = null;
        try {
            if (fc.getAlgorithm().equals(SharedData.algorithm_Full)) {
                OutputStream out = new FileOutputStream("Cloud\\Server\\" + file.getName());
                bytes = (byte[]) client.in.readObject();
                out.write(bytes);
                out.flush();
                out.close();
                for (ClientData cd : ServerFrame.clients) {
                    if (!cd.id.equals(client.id)) {
                        cd.out.writeObject(fc);
                        cd.out.flush();
                        cd.out.writeObject(bytes);
                        cd.out.flush();
                    }
                }
                //return bytes;
            } else if (fc.getAlgorithm().equals(SharedData.algorithm_My)) {
                String clientFileHash = (String) client.in.readObject();
                //System.out.println("clientFileHash : " + clientFileHash);
                HashMap<Integer, String> clientblocksSoftHashes = (HashMap<Integer, String>) client.in.readObject();
                HashMap<Integer, String> clientblocksHardHashes = (HashMap<Integer, String>) client.in.readObject();
                int lastBlockSize = (int) client.in.readObject();
                SharedData.textareaBocks.setText(client.id + " File : " + file.getName()
                        + "\n" + Hashes.HashesToString(clientblocksSoftHashes, clientblocksHardHashes)
                        + "\n" + SharedData.textareaBocks.getText());
                File1 myAlgo = new File1();
                String data = myAlgo.start(file, clientFileHash, lastBlockSize, clientblocksSoftHashes, clientblocksHardHashes);
                if (data != null) {
                    SharedData.textareaBocks.setText(data + "\n" + SharedData.textareaBocks.getText());
                    this.client.out.writeObject(FileRecord.getSendBlocksRecord(file));
                    this.client.out.flush();
                    System.out.println("send MyAgorothm.blocksNotFound : " + myAlgo.blocksNotFound);
                    this.client.out.writeObject(myAlgo.blocksNotFound);
                    this.client.out.flush();
                    HashMap<Integer, byte[]> clientblocksData = (HashMap<Integer, byte[]>) client.in.readObject();
                    FileCreater.createFile(myAlgo.bytes, file, clientblocksData, myAlgo.blocksRecords, myAlgo.lastBlockSize);

                    //send ServerblocksRecords to all clients
                    for (ClientData cd : ServerFrame.clients) {
                        if (!cd.id.equals(client.id)) {
                            cd.out.writeObject(FileRecord.getReceiveBlocksRecord(file));
                            cd.out.flush();
                            cd.out.writeObject(myAlgo.blocksRecords);
                            cd.out.flush();
                            cd.out.writeObject(myAlgo.lastBlockSize);
                            cd.out.flush();
                        }
                    }
                } else {
                    SharedData.textareaBocks.setText(file.getName() + " does not need modify." + "\n" + SharedData.textareaBocks.getText());
                }

            } else {  //SharedData.algorithm_Rsyn
                String clientFileHash = (String) client.in.readObject();
                //System.out.println("clientFileHash : " + clientFileHash);
                HashMap<Integer, String> clientblocksSoftHashes = (HashMap<Integer, String>) client.in.readObject();
                HashMap<Integer, String> clientblocksHardHashes = (HashMap<Integer, String>) client.in.readObject();
                int lastBlockSize = (int) client.in.readObject();
                SharedData.textareaBocks.setText(client.id + " File : " + file.getName()
                        + "\n" + Hashes.HashesToString(clientblocksSoftHashes, clientblocksHardHashes)
                        + "\n" + SharedData.textareaBocks.getText());
                File2 rsyn = new File2();
                String data = rsyn.startRsyn(file, clientFileHash, lastBlockSize, clientblocksSoftHashes, clientblocksHardHashes);
                if (data != null) {
                    SharedData.textareaBocks.setText(data + "\n" + SharedData.textareaBocks.getText());
                    this.client.out.writeObject(FileRecord.getSendBlocksRecord(file));
                    this.client.out.flush();
                    System.out.println("send MyAgorothm.blocksNotFound : " + rsyn.blocksNotFound);
                    this.client.out.writeObject(rsyn.blocksNotFound);
                    this.client.out.flush();
                    HashMap<Integer, byte[]> clientblocksData = (HashMap<Integer, byte[]>) client.in.readObject();
                    FileCreater.createFile(rsyn.bytes, file, clientblocksData, rsyn.blocksRecords, rsyn.lastBlockSize);

                    //send ServerblocksRecords to all clients
                    for (ClientData cd : ServerFrame.clients) {
                        if (!cd.id.equals(client.id)) {
                            cd.out.writeObject(FileRecord.getReceiveBlocksRecord(file));
                            cd.out.flush();
                            cd.out.writeObject(rsyn.blocksRecords);
                            cd.out.flush();
                            cd.out.writeObject(rsyn.lastBlockSize);
                            cd.out.flush();
                        }
                    }
                } else {
                    SharedData.textareaBocks.setText(file.getName() + " does not need modify." + "\n" + SharedData.textareaBocks.getText());
                }
                //return bytes;
            }

        } catch (Exception ex) {
            ex.printStackTrace();
            System.out.println("file receive error");
            //doEvent("deleted:#" + file.getName());
            //return null;
        }
    }

    // type ==0 wait | type ==1 stop wait
    public void sendWaitRecordAllClients(int type) throws IOException {

        if (type == 0) {
            SharedData.waitingProgressBar.setVisible(true);
            for (ClientData cd : ServerFrame.clients) {
                //if (!cd.id.equals(client.id)) {
                cd.out.writeObject(FileRecord.getSynWaitingRecord());
                cd.out.flush();
                //}
            }
        } else {
            SharedData.waitingProgressBar.setVisible(false);
            for (ClientData cd : ServerFrame.clients) {
                //if (!cd.id.equals(client.id)) {
                cd.out.writeObject(FileRecord.getSynStopRecord());
                cd.out.flush();
                //}
            }
        }
    }
}
